<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>shuyufang.com/</title>
   
   <link>http://localhost:4000</link>
   <description>唯刀百辟 唯心不易</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>使用Docker搭建Nginx+Php-fpm+Mysql</title>
	  <link>//docker-nginx-phpfpm-mysql</link>
	  <author></author>
	  <pubDate>2018-03-31T00:00:00+08:00</pubDate>
	  <guid>//docker-nginx-phpfpm-mysql</guid>
	  <description><![CDATA[
	     <h2 id="搭建mysql">搭建MySQL</h2>

<h4 id="step1-启动新的mysql容器实例">step1: 启动新的MySQL容器实例</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container run \                      # 启动一个新的容器实例，若容器对应的镜像不存在则自动从配置的远程仓库拉取
    -d \                                      # 指定容器实例在后台运行
    --rm \                                    # 当容器实例停止时，自动清理资源并删除该实例
    --name MyDockerMysql \                    # 指定容器实例的名称
    -p 3307:3306 \                            # 绑定本地3307端口至容器实例的3306端口
    --env MYSQL_ROOT_PASSWORD=123456 \        # 指定容器实例启动时的环境变量，MYSQL_ROOT_PASSWORD对应MySQL初始化的root密码
    mysql:5.7                                 # 指定容器镜像的名称和标识，用于从本地或远程仓库中查找用于实例化的镜像
</code></pre></div></div>

<h4 id="step2-检查是否启动成功">step2: 检查是否启动成功</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container ls --all
</code></pre></div></div>
<ul>
  <li>若启动成功，在执行完该命令后可以看到名称为”MyDockerMysql”的运行中的容器实例，同时还可以看到该实例的ID。若启动失败，则没有实例信息，此时可以把启动命令中的”-d”选项删去，重新执行以便查看错误情况。</li>
</ul>

<h4 id="step3-查看实例的虚拟ip">step3: 查看实例的虚拟IP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container inspect MyDockerMysql | grep IPAddress
</code></pre></div></div>
<ul>
  <li>一般该IP为172.17.0.xx，后面的php测试脚本需要MySQL的IP信息。</li>
</ul>

<h4 id="step4-在mysql中新建数据库">step4: 在MySQL中新建数据库</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mysql -h127.0.0.1 -P3307 -uroot -p123456
</code></pre></div></div>
<ul>
  <li>执行这一步时，需要在本地先安装mysql客户端，”-h”和”-P”选项用于指定MySQL的服务端IP和端口，由于启动实例时已指定了端口映射，因此指定”127.0.0.1:3307”与”172.17.0.xx:3306”都可以，”-u”和”-p”分别用于指定MySQL的用户名和密码。
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; create database MyDockerDb;
</code></pre></div>    </div>
  </li>
  <li>新建名称为MyDockerDb的数据库。</li>
</ul>

<h2 id="搭建php-fpm">搭建Php-fpm</h2>

<h4 id="step1-创建本地映射目录与测试脚本">step1: 创建本地映射目录与测试脚本</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mkdir -p /data/MyDockerPhpfpm &amp;&amp; cd /data/MyDockerPhpfpm &amp;&amp; vim test.php
</code></pre></div></div>
<ul>
  <li>测试脚本的名称为”test.php”，内容如下：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?php
$host = '172.17.0.4';        // 与上文中的MySQL容器实例的虚拟IP地址保持一致
$port = 3306;
$user = 'root';
$password = '123456';
$db = 'MyDockerDb';
$mysqli = new mysqli($host, $port, $user, $password, $db);
if ($mysqli-&gt;connect_error) {
  die('Connect Db Error(' . $mysqli-&gt;connect_errno . ') ' . $mysqli-&gt;connect_error);
}
echo 'Success... ' . $mysqli-&gt;host_info . "\n" . PHP_EOL;
$mysqli-&gt;close();
?&gt;
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="step2-启动新的php-fpm实例">step2: 启动新的Php-fpm实例</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container run \                      # 启动一个新的容器实例，若容器对应的镜像不存在则自动从配置的远程仓库拉取
    -d \                                      # 指定容器实例在后台运行
    --rm \                                    # 当容器实例停止时，自动清理资源并删除该实例
    --name MyDockerPhpfpm \                   # 指定容器实例的名称
    -v "/data/MyDockerPhpfpm/":/data          # 指定目录映射，本地的/data/MyDocker映射至容器实例的/data目录
    bitnami/php-fpm                           # 指定容器镜像的名称，用于从本地或远程仓库中查找用于实例化的镜像
</code></pre></div></div>

<h4 id="step3-检查是否启动成功">step3: 检查是否启动成功</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container ls --all
</code></pre></div></div>
<ul>
  <li>若启动成功，在执行完该命令后可以看到名称为”MyDockerPhpfpm”的运行中的容器实例，同时还可以看到该实例的ID。若启动失败，则没有实例信息，此时可以把启动命令中的”-d”选项删去，重新执行以便查看错误情况。Php-fpm的默认监听端口为9000。</li>
</ul>

<h4 id="step4-查看实例的虚拟ip">step4: 查看实例的虚拟IP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container inspect MyDockerPhpfpm | grep IPAddress
</code></pre></div></div>
<ul>
  <li>一般该IP为172.17.0.xx，后面的nginx服务需要php-fpm的IP信息。</li>
</ul>

<h2 id="搭建nginx">搭建Nginx</h2>

<h4 id="step1-创建用于映射的本地nginx配置文件">step1: 创建用于映射的本地nginx配置文件</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mkdir /data/MyDockerNginx &amp;&amp; cd /data/MyDockerNginx &amp;&amp; vim nginx.conf
</code></pre></div></div>
<ul>
  <li>“nginx.conf”是nginx默认配置文件的名称，该文件用于映射至容器实例的nginx配置文件，内容如下：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_processes  1;
pid        nginx.pid;
events {
  worker_connections  256;
}
http {
  include       mime.types;
  default_type  application/octet-stream;
  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
  sendfile        on;
  keepalive_timeout  65;
  port_in_redirect    off;
  tcp_nopush     on;
  server {
      listen       80;                          # 监听80端口
      server_name  localhost;
      index index.php index.html index.htm;
      root /data/MyDockerPhpfpm;                # 与Php-fpm容器实例中测试脚本所在目录保持一致
      error_page  500 502 503 504 /50x.html;
      location = /50x.html {
          root html;
      }
      location ~ .*\.php$ {                     # 当访问的资源名称以php结尾时，将请求转发至fastcgi处理器
          fastcgi_pass     172.17.0.2:9000;     # 与上文中的Php-fpm容器的虚拟IP地址保持一致
          fastcgi_index    index.php;
          fastcgi_param    SCRIPT_FILENAME    $document_root$fastcgi_script_name;
          fastcgi_param    SCRIPT_NAME    $fastcgi_script_name;
          include          fastcgi_params;
      }
  }
}
</code></pre></div>    </div>
  </li>
  <li>配置文件主要指定nginx监听的端口、fastcgi处理方式等信息，若对此不熟悉可参考nginx官方文档。</li>
</ul>

<h4 id="step2-启动新的nginx实例">step2: 启动新的nginx实例</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container run \                      # 启动一个新的容器实例，若容器对应的镜像不存在则自动从配置的远程仓库拉取
    -d \                                      # 指定容器实例在后台运行
    --rm \                                    # 当容器实例停止时，自动清理资源并删除该实例
    --name MyDockerNginx \                    # 指定容器实例的名称
    -p 8080:80 \                              # 绑定本地8080端口至容器实例的80端口
    -v "/data/MyDockerNginx/nginx.conf":/etc/nginx/nginx.conf   # 指定文件映射
    nginx                                     # 指定容器镜像的名称，用于从本地或远程仓库中查找用于实例化的镜像
</code></pre></div></div>
<ul>
  <li>/etc/nginx/nginx.conf是nginx容器实例中默认的nginx配置文件，启动的时候docker会把本地的文件自动映射至容器中。本地的8080端口映射容器的80端口，意味着后面我们访问本地的8080端口时，系统会自动将请求转发至nginx容器实例的80端口。</li>
</ul>

<h4 id="step3-检查是否启动成功-1">step3: 检查是否启动成功</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker container ls --all
</code></pre></div></div>
<ul>
  <li>若启动成功，在执行完该命令后可以看到名称为”MyDockerNginx”的运行中的容器实例，同时还可以看到该实例的ID。若启动失败，则没有实例信息，此时可以把启动命令中的”-d”选项删去，重新执行以便查看错误情况。</li>
</ul>

<h2 id="验证整体效果">验证整体效果</h2>
<ul>
  <li>打开本地浏览器，输入localhost:8080/test.php，若页面显示”Success…”说明上文的搭建已成功，否则需要排查问题，这里列举下搭建过程中可能遇到的问题及解决思路。</li>
</ul>

<h4 id="服务器连接失败">服务器连接失败</h4>
<ul>
  <li>这种错误说明请求未找到对应的服务器，可能是nginx实例未启动或不在运行状态，也可能是url中的域名与端口不正确。</li>
</ul>

<h4 id="nginx返回404">Nginx返回404</h4>
<ul>
  <li>这种错误说明nginx未找到请求的资源，需要检查Php-fpm容器实例是否正常运行，测试脚本名称是否正确，fastcgi相关配置是否正确，测试脚本是否真的位于Php-fpm容器实例的对应目录中。</li>
</ul>

<h4 id="nginx返回403">Nginx返回403</h4>
<ul>
  <li>这种错误说明客户端没有权限访问该资源，可能是fastcgi的root根目录选项未正确配置（未与Php-fpm容器实例中的测试目录保持一致），也可能是Php-fpm实例中的测试目录或测试脚本的权限未正确设置。</li>
</ul>

<h4 id="数据库相关错误">数据库相关错误</h4>
<ul>
  <li>这类错误说明连接数据库失败或选择指定的数据库失败，需要检查MySQL容器实例是否正常运行，数据库的相关信息（服务器地址、用户名、密码、数据库名称等）是否正确。</li>
</ul>

<h2 id="参考资料">参考资料</h2>
<ul>
  <li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>常用哈希函数C语言实现</title>
	  <link>//hash-functions-c</link>
	  <author></author>
	  <pubDate>2017-04-22T00:00:00+08:00</pubDate>
	  <guid>//hash-functions-c</guid>
	  <description><![CDATA[
	     <h2 id="sdbm-hash">SDBM Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int SDBMHash(char *str)
{
    unsigned int hash = 0;
 
    while (*str)
    {
        // equivalent to: hash = 65599*hash + (*str++);
        hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="rs-hash">RS Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int RSHash(char *str)
{
    unsigned int b = 378551;
    unsigned int a = 63689;
    unsigned int hash = 0;
 
    while (*str)
    {
        hash = hash * a + (*str++);
        a *= b;
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="js-hash">JS Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int JSHash(char *str)
{
    unsigned int hash = 1315423911;
 
    while (*str)
    {
        hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2));
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="p-j-weinberger-hash">P. J. Weinberger Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int PJWHash(char *str)
{
    unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);
    unsigned int ThreeQuarters    = (unsigned int)((BitsInUnignedInt  * 3) / 4);
    unsigned int OneEighth = (unsigned int)(BitsInUnignedInt / 8);
    unsigned int HighBits = (unsigned int)(0xFFFFFFFF) &lt;&lt; (BitsInUnignedInt 
                                               - OneEighth);
    unsigned int hash    = 0;
    unsigned int test    = 0;
 
    while (*str)
    {
        hash = (hash &lt;&lt; OneEighth) + (*str++);
        if ((test = hash &amp; HighBits) != 0)
        {
            hash = ((hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits));
        }
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="elf-hash">ELF Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int ELFHash(char *str)
{
    unsigned int hash = 0;
    unsigned int x    = 0;
 
    while (*str)
    {
        hash = (hash &lt;&lt; 4) + (*str++);
        if ((x = hash &amp; 0xF0000000L) != 0)
        {
            hash ^= (x &gt;&gt; 24);
            hash &amp;= ~x;
        }
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="bkdr-hash">BKDR Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int BKDRHash(char *str)
{
    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
    unsigned int hash = 0;
 
    while (*str)
    {
        hash = hash * seed + (*str++);
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="djb-hash">DJB Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int DJBHash(char *str)
{
    unsigned int hash = 5381;
 
    while (*str)
    {
        hash += (hash &lt;&lt; 5) + (*str++);
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

<h2 id="ap-hash">AP Hash</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int APHash(char *str)
{
    unsigned int hash = 0;
    int i;
 
    for (i=0; *str; i++)
    {
        if ((i &amp; 1) == 0)
        {
            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));
        }
        else
        {
            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));
        }
    }
 
    return (hash &amp; 0x7FFFFFFF);
}
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 95 [Unique Binary Search Trees II]</title>
	  <link>//leetcode-unique-binary-search-trees-ii</link>
	  <author></author>
	  <pubDate>2017-04-01T00:00:00+08:00</pubDate>
	  <guid>//leetcode-unique-binary-search-trees-ii</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">https://leetcode.com/problems/unique-binary-search-trees-ii/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一个整数，要求返回所有由值为1-n的结点组成的二叉排序树。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>首先需要考虑n的取值，若取值不大于0，则不会形成任何二叉树。</li>
  <li>对于n&gt;0的情况，可以用分治的思想来处理，每个结点轮流作为根结点，那么它的左子树就是由所有比该结点的值小的其他结点构成的，它的右子树就是由所有比该结点大的值构成的。</li>
  <li>对于左子树与右子树，又可以轮流以某个结点作为根结点，一直到无法再分为止。</li>
  <li>由于左子树可能有a种形式，右子树也可能有b种形式，所以以某个结点为根的树的集合其实需要对左右子树的情况进行一一匹配，最终可以得出a*b种形式。</li>
  <li>需要特别注意一种情况，子树为空或者仅有一个结点，这两种情况实质都包含了一种形式，需要同等考虑。</li>
  <li>每次以某个结点为根进行计算，平均时间复杂度为O(log n)，对n个结点进行计算，时间复杂度即为O(n * log n)。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode*&gt; generateTrees(int n) {
        vector&lt;TreeNode*&gt; result;
        if (n &lt; 1) {
            return result;
        }
        return generateTreesOfRange(1, n);
    }
    vector&lt;TreeNode*&gt; generateTreesOfRange(int beg, int end) {
        vector&lt;TreeNode*&gt; result;
        if (beg &gt; end) {
            result.push_back(NULL);
            return result;
        }
        for (int i = beg; i &lt;= end; ++i) {
            vector&lt;TreeNode*&gt; leftTrees = generateTreesOfRange(beg, i - 1);
            vector&lt;TreeNode*&gt; rightTrees = generateTreesOfRange(i + 1, end);
            for (int j = 0; j &lt; leftTrees.size(); ++j) {
                for (int k = 0; k &lt; rightTrees.size(); ++k) {
                    TreeNode* root = new TreeNode(i);
                    root-&gt;left = leftTrees[j];
                    root-&gt;right = rightTrees[k];
                    result.push_back(root);
                }
            }
        }
        return result;
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 116 [Populating Next Right Pointers in Each Node]</title>
	  <link>//leetcode-populating-next-right-pointers-in-each-node</link>
	  <author></author>
	  <pubDate>2017-04-01T00:00:00+08:00</pubDate>
	  <guid>//leetcode-populating-next-right-pointers-in-each-node</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一颗完美二叉树，要求将每个结点的next指针指向它右侧的结点，若它右侧没有结点，则指向NULL，处理过程只能使用常量复杂度的空间。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>对于任意两个在完美二叉树上左右相邻的结点，它们必定满足以下两个规则之一：
    <ol>
      <li>它们有同一个父结点，即任意一个结点的左右子结点必然是相邻的。</li>
      <li>两个结点的父结点相邻，并且位于左侧的结点是它的父结点的右子结点，位于右侧的结点是它的父结点的左子结点。</li>
    </ol>
  </li>
  <li>既然确定了左右相邻的结点的特征，那么只需要从根结点开始遍历树的所有结点并对应处理即可，处理过程如下：
    <ol>
      <li>对于每个结点，若左子结点存在，那么右子结点也必然存在，则将左子结点的next指针指向右子结点。</li>
      <li>对于每个结点，若它的左子结点也存在右子结点，那么它的右子结点也存在左子结点，则将它的左子结点的右子结点的next指针，指向它的右子结点的左子结点。</li>
    </ol>
  </li>
  <li>处理过程中，每个结点都被遍历了一次，因此时间复杂度是O(n)。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        if (root-&gt;next &amp;&amp; root-&gt;right) root-&gt;right-&gt;next = root-&gt;next-&gt;left;
        if (root-&gt;left) {
            root-&gt;left-&gt;next = root-&gt;right;
            connect(root-&gt;left);
            connect(root-&gt;right);
        }
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 117 [Populating Next Right Pointers in Each Node II]</title>
	  <link>//leetcode-populating-next-right-pointers-in-each-node-ii</link>
	  <author></author>
	  <pubDate>2017-04-01T00:00:00+08:00</pubDate>
	  <guid>//leetcode-populating-next-right-pointers-in-each-node-ii</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一颗二叉树，要求将每个结点的next指针指向它右侧的结点，若它右侧没有结点，则指向NULL，处理过程只能使用常量复杂度的空间。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>本题与题目116不一样的地方在于给定的二叉树是普通的，除了二叉树的基本特征之外，没有其他可以利用的特点。</li>
  <li>若不限制使用的空间的复杂度，我们就可以通过遍历，把每一层最近一次被访问的结点记录下来，每次访问到同一层的下一个结点，就把记录的同层的结点的next指针指向当前结点，再把当前结点作为本层最近一次被访问的结点记录下来，这样遍历完之后next指针也就构建完毕了。</li>
  <li>对于限制空间复杂度的条件，我们只能通过时间换空间的方式来解决。解决的方式是每一次遍历，目标仅针对特定某一层的结点，具体步骤如下：
    <ol>
      <li>假如根结点深度为0，叶结点最深的深度为h，在进行每一轮遍历之前，将辅助记录本层上一次访问的结点的指针置为NULL。</li>
      <li>进行一轮遍历时，从根结点开始，若当前结点的深度与本次遍历的目标层的深度一致，则对应更新next指针与辅助指针，对于深度超过目标的结点不需要遍历。</li>
      <li>每一轮遍历结束之后，若辅助指针不为NULL，说明需要继续下一轮遍历.</li>
      <li>经过h轮遍历之后，next指针即构建完毕。</li>
    </ol>
  </li>
  <li>假设二叉树高度为h，则处理过程对树遍历了h轮，设 0 &lt; i &lt;= h，则第i轮最多遍历 sum(2^0 + 2^1 + … + 2^(i-1)) 个结点，第i轮遍历的时间复杂度为O(2^i)，因此最终时间复杂度为O(h * 2^h)。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void travel(TreeLinkNode* node, int height, TreeLinkNode** lastNode, int level) {
    	if (!node) {
    		return;
    	}
    	if (height == level) {
    		if (*lastNode) {
    			(*lastNode)-&gt;next = node;
    		}
    		*lastNode = node;
    		return;
    	}
    	travel(node-&gt;left, height + 1, lastNode, level);
    	travel(node-&gt;right, height + 1, lastNode, level);
    }
    
    void connect(TreeLinkNode *root) {
    	TreeLinkNode* lastNode = NULL;
    	int level = 0;
    	do {
    		lastNode = NULL;
    		travel(root, 0, &amp;lastNode, level);
            level++;
    	} while (lastNode);
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 108 [Convert Sorted Array to Binary Search Tree]</title>
	  <link>//leetcode-convert-sorted-array-to-binary-search-tree</link>
	  <author></author>
	  <pubDate>2017-04-01T00:00:00+08:00</pubDate>
	  <guid>//leetcode-convert-sorted-array-to-binary-search-tree</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一个由小到大排好序的数组，要求将每个数组的值作为一个结点的值，将结点构建成一棵平衡的二叉排序树。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>如果二叉树是平衡的，则它的任意一个结点的左子树和右子树的高度差不超过1。</li>
  <li>数组是由小到大有序的，可以考虑用二分法找到中间元素作为根结点的值，再把根结点的左右两边看成两个子数组，左子数组的元素都比根结点的值小，右子数组的元素都比根结点的值大。若原数组的元素个数是奇数，那么根结点的值刚好是位于中间的元素，左右子数组的元素个数相同；若原数组的元素个数是偶数，那么根结点的值则是中间偏左的元素或中间偏右的元素，左右子数组的元素个数差值为1。继续对左右子数组进行递归处理，直到不能再划分。</li>
  <li>用这种方法，最后一层得到树必然是平衡的，根结点的父结点对应的树也是平衡的，进而可以推断出最终构建出来的二叉树是二叉平衡树。另外，在每次构建过程中都可以保证左子树的所有结点的值都比根结点小，右子树的所有结点的值都比根结点大，因此最终构建出来的二叉树是二叉排序树。</li>
  <li>若原数组元素个数为n，则处理过程的时间复杂度为O(log n)。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return convert(nums, 0, nums.size() - 1);
    }
    TreeNode* convert(vector&lt;int&gt;&amp; nums, int begin, int end) {
        if (begin &gt; end) {
            return NULL;
        }
        if (begin == end) {
            return new TreeNode(nums[begin]);
        }
        int mid = ((begin + end) &gt;&gt; 1);
        TreeNode* node = new TreeNode(nums[mid]);
        node-&gt;left = convert(nums, begin, mid - 1);
        node-&gt;right = convert(nums, mid + 1, end);
        return node;
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 538 [Convert BST to Greater Tree]</title>
	  <link>//leetcode-convert-bst-to-greater-tree</link>
	  <author></author>
	  <pubDate>2017-03-29T00:00:00+08:00</pubDate>
	  <guid>//leetcode-convert-bst-to-greater-tree</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一颗二叉排序树，对于每个结点，要求计算出所有比它的值大的结点的值的和，并且将这个计算出来的和加到该结点上面。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>首先需要确定如何找到所有比某个结点的值大的其他所有结点。在二叉排序树中，父结点的值总是大于左子树所有结点的值，且小于右子树所有结点的值。所以比某个结点的值大的所有结点，也就是在先序遍历中位于它之后的所有结点。</li>
  <li>本题的要求是将这些结点的值的和加到该结点上面，因此我们不需要逐个查找结点，再逐个加上去，整体处理就可以了。对于每个结点，我们需要记录父结点传下来的增量（简述为“父增量”），它自身变更前的值（简述为“原值”），左子树所有结点变更之前的值的和（简述为“左侧总和”），右子树所有结点变更之前的值的和（简述为“右侧总和”），然后将“原值+右侧总和+父增量”作为增量加到左子树的每个结点上面，将“父增量”作为增量加到右子树的每个结点上，再将“右侧总和+父增量”作为增量加到自身上面。处理左右结点的流程与其父结点是一致的，递归处理即可。</li>
  <li>变更结点的值以及计算当前的树的所有结点的值的总和，这两个流程可以在一次遍历中完成，通过不同的变量来记录变更前后的值即可。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        int rootOriginSum, rootNewSum;
        convertNode(root, rootOriginSum, 0, rootNewSum);
        return root;
    }
    void convertNode(TreeNode* node, int&amp; originSum, int delta, int&amp; newSum) {
        if (!node) {
            originSum = 0;
            newSum = 0;
            return;
        }
        int rightOriginSum, rightNewSum;
        convertNode(node-&gt;right, rightOriginSum, delta, rightNewSum);
        int leftOriginSum, leftNewSum;
        convertNode(node-&gt;left, leftOriginSum, delta + node-&gt;val + rightOriginSum, leftNewSum);
        originSum = node-&gt;val + leftOriginSum + rightOriginSum;
        node-&gt;val += delta + rightOriginSum;
        newSum = node-&gt;val + leftNewSum + rightNewSum;
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 113 [Path Sum II]</title>
	  <link>//leetcode-path-sum-ii</link>
	  <author></author>
	  <pubDate>2017-03-29T00:00:00+08:00</pubDate>
	  <guid>//leetcode-path-sum-ii</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/path-sum-ii/">https://leetcode.com/problems/path-sum-ii/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一棵二叉树与一个整数值，要求查找出所有从根结点到叶子结点的路径，这些路径上的所有结点的和等于给定的值。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>题目默认条件：
    <ul>
      <li>不需要考虑子路径结点的和可能溢出的情况。</li>
    </ul>
  </li>
  <li>本题主要关注点在于三个方面：
    <ol>
      <li>如何判断某个结点是不是叶子结点：
        <ul>
          <li>如果该结点没有左子结点与右子结点，则该结点是叶子结点，根结点也可能是叶子结点。</li>
        </ul>
      </li>
      <li>若采用递归的方式，如何减少内存空间的使用：
 -存放临时路径的vector，在整个遍历过程都使用引用来传递该临时路径，每个结点处理之后需要清理对该路径的变更。
        <ul>
          <li>存放结果的vector，在整个遍历过程中同样使用引用来传递。</li>
        </ul>
      </li>
      <li>如何判断某条路径满足条件：
        <ul>
          <li>在遍历过程中，用一个变量实时记录临时路径的值，若某个结点是叶子结点，并且该变量的值与给定值相等，则当前的临时路径满足条件，可加入存放结果的vector中。</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; subPath;
        if (root) {
            calculatePathSum(root, sum, subPath, 0, result);
        }
        return result;
    }
    void calculatePathSum(TreeNode* node, int sum, vector&lt;int&gt;&amp; subPath, int subSum, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        subPath.push_back(node-&gt;val);
        subSum += node-&gt;val;
        if (!node-&gt;left &amp;&amp; !node-&gt;right) {
            if (sum == subSum) {
                result.push_back(subPath);
            }
        }
        if (node-&gt;left) {
            calculatePathSum(node-&gt;left, sum, subPath, subSum, result);
        }
        if (node-&gt;right) {
            calculatePathSum(node-&gt;right, sum, subPath, subSum, result);
        }
        subSum -= node-&gt;val;
        subPath.pop_back();
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 222 [Count Complete Tree Nodes]</title>
	  <link>//leetcode-count-complete-tree-nodes</link>
	  <author></author>
	  <pubDate>2017-03-20T00:00:00+08:00</pubDate>
	  <guid>//leetcode-count-complete-tree-nodes</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/count-complete-tree-nodes/">https://leetcode.com/problems/count-complete-tree-nodes/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>给定一棵完全二叉树，要求计算它的总结点数。完全二叉树指的是除了最后一层之外，其他每一层都是完整的，最后一层可能不是完整的，但是这一层的结点全部聚集在左侧，因此完全二叉树的结点数落在(1，2^h)这个区间内。</li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>一开始我使用最简单的方式来处理，完全二叉树是特殊的二叉树，只要把它的结点全部遍历一次就可以了。这种方法可以得到结果，但是时间复杂度为O(n)，直接超时了。</li>
  <li>接着我改进了计算方式，从最右侧开始遍历，当发现最后一层某个位置有结点的时候就停止。这种方法在平均情况下只需要遍历一半的结点，但是时间复杂度还是O(n)，还是超时。</li>
  <li>时间复杂度为O(n)行不通，只能考虑O(log n)的算法，而O(log n)的时间复杂度一般对应着二分法。对于这个题目，可以通过二分法查找最后一层的最后一个结点的位置，进而计算出总结点数，具体的算法如下：
    <ol>
      <li>首先计算树的高度，由根结点一直往左偏移，计算偏移次数即可，这一步的时间复杂度为O(log n)。</li>
      <li>除了树为空或者仅有根结点的情况，完全二叉树的倒数第二层肯定是完整的，因此可以通过倒数第二层的结点来判断最后一层的结点的分布情况。</li>
      <li>从根结点开始处理，以当前结点为中间线，将以当前结点为根的二叉树分成两部分，取倒数第二层中，左半部分最靠近中间线的结点，即之前描述的二分的方式。这个处于“二分位置偏左”的结点，称之为“二分结点”，必然是当前结点的左子树（不考虑原树最后一层）的最右边的结点。</li>
      <li>如果“二分结点”有右子结点，说明上述的左半部分是完整的，继续考虑右半部分，将当前结点向它的右结点偏移。</li>
      <li>如果“二分结点”没有右子结点，说明上述的左半部分不是完整的，右半部分最后一层的结点全部缺失，记录对应的缺失结点数之后，将当前结点向它的左结点偏移。</li>
      <li>对新的当前结点进行处理，直到当前结点位于倒数第二层，这种情况下以当前结点为根的树（不考虑原树最后一层）仅有一个结点，无法拆分为左右两部分，因此直接根据它的左右子结点是否为空，对应记录缺失的结点数即可。</li>
      <li>倒数第二层处理完之后，处理流程结束，计算相同高度的满二叉树的结点数，用它减去缺失的结点数，即为所求的完全二叉树的结点数。</li>
    </ol>
  </li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
#include &lt;math&gt;
class Solution {
public:
    int countNodes(TreeNode* root) {
        // 计算树的高度
        int height = 0;
        TreeNode* tmp = root;
        while (tmp) {
            height++;
            tmp = tmp-&gt;left;
        }
        
        // 记录缺少的结点数
        int numRightEmpty = 0;
        
        TreeNode* node = root;
        TreeNode* curNode;
        int level = 1;
        int curLevel;
        
        // 从根结点开始遍历，直到当前结点为空，或者已遍历到最后一层
        while (node &amp;&amp; level &lt; height) {
            // 如果当前结点位于倒数第二层，则处理完它的子结点的情况之后即可结束
            if (level == height - 1) {
                numRightEmpty += node-&gt;right ? 0 : node-&gt;left ? 1 : 2;
                break;
            }
            
            // 以当前结点位置为中间线，查找倒数第二层里面，中间线偏左的最后一个元素
            // 查找方法为当前结点向左下方偏移，再一直向右下方偏移，直到倒数第二层为止
            curNode = node-&gt;left;
            curLevel = level + 1;
            while (curLevel &lt; height - 1) {
                curNode = curNode-&gt;right;
                curLevel++;
            }
            
            // 如果中间线偏左的最后一个元素有右子结点，则需要将当前结点重置为它的右子结点
            // 如果中间线偏左的最后一个元素没有右子结点，那么说明当前结点缺少了右半边的叶子结点，对应处理之后，将当前结点重置为它的左子结点
            if (curNode-&gt;right) {
                node = node-&gt;right;
            } else {
                numRightEmpty += (int)pow(2.0, (double)(height - level - 1));
                node = node-&gt;left;
            }
            level++;
        }
        
        // 总的结点数为（2^h - 1 - 缺少的结点数）
        return (int)pow(2.0, (double)(height)) - 1 - numRightEmpty;
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>LeetCode 98 [Validate Binary Search Tree]</title>
	  <link>//leetcode-validate-binary-search-tree</link>
	  <author></author>
	  <pubDate>2017-03-19T00:00:00+08:00</pubDate>
	  <guid>//leetcode-validate-binary-search-tree</guid>
	  <description><![CDATA[
	     <h2 id="题目链接">题目链接</h2>
<ul>
  <li><a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>
<ul>
  <li>判断给定的二叉树是不是二叉排序树，假定二叉排序树满足以下条件：
    <ol>
      <li>任意一个结点的左子树的所有结点的值都比该结点小。</li>
      <li>任意一个结点的右子树的所有结点的值都比该结点大。</li>
      <li>左子树和右子树都是二叉排序树（递归定义）。</li>
    </ol>
  </li>
</ul>

<h2 id="解题思路">解题思路</h2>
<ol>
  <li>根据二叉排序树的定义，从根结点出发，验证以每一个结点为根的树是否满足条件。</li>
  <li>对每一个被遍历的结点，若左子结点不为空，则查找左子树的所有结点的最大值，若该值不小于当前结点的值，则说明当前树不是二叉排序树，否则继续查找右子树的所有结点的最小值，若该值不大于当前结点的值，则同样说明当前树不是二叉排序树。</li>
  <li>实际代码实现使用递归的方式，最大值被初始化为整型的最小值，最小值被初始化为整型的最大值，由上层调用时传入。</li>
</ol>

<h2 id="c代码">C++代码</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if (!root) {
            return true;
        }
        int max = INT_MIN;
        int min = INT_MAX;
        return travel(root, max, min);
    }
    
    bool travel(TreeNode* node, int&amp; max, int&amp; min) {
        max = node-&gt;val &gt; max ? node-&gt;val : max;
        min = node-&gt;val &lt; min ? node-&gt;val : min;
        
        int tmpmax, tmpmin;
        
        if (node-&gt;left) {
            tmpmax = INT_MIN;
            tmpmin = INT_MAX;
            if (!travel(node-&gt;left, tmpmax, tmpmin)) {
                return false;
            } else if (tmpmax &gt;= node-&gt;val) {
                return false;
            }
            max = tmpmax &gt; max ? tmpmax : max;
            min = tmpmin &lt; min ? tmpmin : min;
        }
        
        if (node-&gt;right) {
            tmpmax = INT_MIN;
            tmpmin = INT_MAX;
            if (!travel(node-&gt;right, tmpmax, tmpmin)) {
                return false;
            } else if (tmpmin &lt;= node-&gt;val) {
                return false;
            }
            max = tmpmax &gt; max ? tmpmax : max;
            min = tmpmin &lt; min ? tmpmin : min;
        }
        
        return true;
    }
};
</code></pre></div></div>

	  ]]></description>
	</item>


</channel>
</rss>
